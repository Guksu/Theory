# **1장**

- 성능 최적화의 목적은 로딩과 렌더링 성능을 극대화 하는것이다.

## **2장**

- 보통 화면에 보이는 픽셀의 2배정도 사이즈의 이미지로 최적화하는게 좋다.
- 이미지 최적화를 위해서 image processiong CDN을 사용한다
- Nextjs 의 경우 Image컴포넌트를 사용하면 좋다.

```
CDN (Contents Delivery Network)이란
소비자와 가까운 곳에 컨텐츠 서버를 두는 기술을 뜻한다.
```

- 개발자도구 performance탭의 Minor GC는 가비지컬렉션으로 메모리를 정리해주는 작업이다.

- 배포 시 텍스트 인코딩을 사용하여 초기 js로드시간을 줄일 수 있다.(서버에서 작업)

## **3장**

- 브라우저는 기본적으로 60Frame(60FPS)을 지원한다. 따라서 초당 프레임이 낮아지면 쟁크현상(애니메이션이 버벅거리는 현상)이 나타난다.
- 브라우저는 DOM+CSSOM --> Render Tree --> Layout --> Paint(색상변경) --> Composite(각 레이어 합성) 과정을 통하여 화면을 보여준다.
- 이 모든 과정을 다시 실행하는것을 Reflow라한다.
- Layout에서 실행되는 width,height등의 변경이 아닌 색상변경만 필요한 경우 Layout과정은 생략된다. 이를 Repaint라한다.
- transform, opacity와 같은 GPU가 관여할 수 있는 작업의 경우 Layout과 Paint과정을 생략할 수 있다.

## **4장**

- 이미지 지연로딩 중 한 방법으로 스크롤이 된 경우에 로딩을 시작하는게 있다. 단, 이 방법은 스크롤 될 때마다 함수가 많이 실행된다. 이 문제를 해결하는게 [Intersection Obsever]이다.
- Intersection Obsever는 해당 객체가 스크롤에 의해 화면에 보여지는지 확인 가능하다.

- 이미지 지연로딩 방법 (화면에 보일경우에만 로딩)

```
const ref = useRef(null)

const callback = (entries,observer) =>{
    //entries는 아래에 observe한 객체들이 배열로 들어온다.
    entries.forEach(entry=>{
        if(entry.isIntersecting){
            //해당 entry가 intersecting될 시 (화면에 보일 시 ) 실행
            entry.target.src = entry.target.dataset.src
            observer.unobserver(entry.target)
        }
    })

}

const observer = new IntersectionObserver(callback, options)

oberver.observe(ref.current);

return(
    <img ref={ref} data-src={imgSrc}>
)
```

- oberver.observe는 해당 객체가 생성될 경우 , 보여질 경우 , 안 보여질 경우 callbakc이 호출된다.

---

- 웹 폰트는 기본적으로 용량이 커서 FOUT(Flash of Unstyled Text)와 FOIT(Flash of Invisible Text)의 문제점을 갖는다.
- 따라서 네트워크가 느린 환경에선 기본폰트가 보여지다가 폰트가 적용되거나 폰트가 다운이 되야 텍스트를 보여주는 경우가 있다.
- IE/Edge에선 FOUT , Crome/Safari에선 FOIT현상이 나타난다.
- CSS의 font-display 속성으로 FOUT와 FOIT의 여부를 결정할 수 있다.

- 폰트는 woff 혹은 woff2형식으로 변경할 경우 용량이 적어진다.

```
@font-face{
    font-family : 폰트;
    //폰트 형식의 우선순위
    src : url(`~.woff2`) format(`woft2`),
          url(`~.woff`) format(`woff`),
          url(`~.ttf`) format(`truetype`),
}
```
