## **자료구조**

1. **Array**
   Array는 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스로 원소에 접근할 수 있다. 그러나 삭제 또는 삽입의 경우에는 배열의 연속성을 유지하기 위하여 시간 복잡도는 O(n)이 된다.

2. **Linked List**
   Linked List는 논리적 저장 순서와 물리적 저장 순서가 일치하지 않지만 각각의 원소들은 자신 다음의 원소와 연결되어 있다. 따라서 삭제 또는 삽입의 경우 시간복잡도는 O(1)이지만 원소를 찾기 위한 복잡도는 O(n)이 된다. 따라서 삭제 / 삽입을 원하는 원소를 찾고 그 다음 삭제 / 삽입이 이루어지기 때문에 실제적인 시간 복잡도는 O(n)이다.

3. **Stack**
   스택은 선형 자료구조의 일종으로 LIFO(Last In First Out)형식이다.

4. **Queue**
   큐 역시 선형 자료구조의 일종으로 FIFO(First In First Out)형식이다.

5. **Tree**
   트리는 비선형 자료구조이며 계층적 관계를 표현한다.

- Node : 트리를 구성하고 있는 각각의 요소를 의마한다.
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
- Root Node : 트리 구조에서 최상위 노드를 의미한다.
- Terminal Node(or Leaf Node ,단말노드) : 하위에 다른 노드가 연결되지 않은 노드
- Internal Node(내부노드 or 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

**Binary Tree(이진 트리)**
루트 노드를 중심으로 두 개의 서브 트리로 나뉘어지며 이들 서브 트리 또한 모두 이진 트리이다. 트리에서는 각 층별로 Level이라 칭하며 루트 노드의 레벨값은 0이다.

- Perfect Binary Tree(포화 이진 트리) : 모든 레벨이 꽉 찬 이진 트리
- Complete Binart Tree(완전 이진 트리) : 위에서 아래로 , 왼쪽에서 오른쪽으로 순서대로 채워진 트리
- Full Binary Tree(정 이진 트리) : 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진트리

배열로 구성된 Binary Tree는 노드의 개수가 n 개이고 root가 0이 아닌 1에서 시작할 때, i 번째 노드에 대해서 parent(i) = i/2 , left_child(i) = 2i , right_child(i) = 2i + 1 의 index 값을 갖는다.

**BST(Binary Search Tree)**
이진 탐색 트리는 이진 트리의 일종으로 다음과 같은 데이터 저장 규칙이 존재한다.

- 규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
- 규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
- 규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
- 규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진 탐색 트리의 시간 복잡도는 O(log n)이다. 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 Rebalancing 기법이 등장하였다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나가 뒤에서 살펴볼 Red-Black Tree이다.

**Binary Heap**
자료구조의 일종으로 Tree 의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다. 배열에 트리의 값들을 넣어줄 때, 0 번째는 건너뛰고 1 번 index 부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index 를 일치시켜 혼동을 줄이기 위함이다. 힙(Heap)에는 최대힙(max heap), 최소힙(min heap) 두 종류가 있다.

Max Heap이란, 각 노드의 값이 해당 children 의 값보다 크거나 같은 complete binary tree를 말한다. ( Min Heap 은 그 반대이다.)

Max Heap에서는 Root node 에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 time complexity 이 O(1)이다. 그리고 complete binary tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다. (즉, random access 가 가능하다. Min heap 에서는 최소값을 찾는데 소요되는 연산의 time complexity 가 O(1)이다.) 하지만 heap 의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap 은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.

6. **Hash Table**
   hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로 average case 에 대하여 시간복잡도가 O(1)이 되는 것이다. 하지만 문제는 이 인덱스로 저장되는 key값이 불규칙하다는 것이다.

그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.

'특별한 알고리즘'이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보인다. 위에서 언급한 '특별한 알고리즘'을 hash method 또는 해시 함수(hash function)라고 하고 이 메소드에 의해 반환된 데이터의 고유 숫자 값을 hashcode라고 한다. 저장되는 값들의 key 값을 hash function을 통해서 작은 범위의 값들로 바꿔준다.
