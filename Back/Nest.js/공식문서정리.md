# **CLI**

- nest g mo : module
- nest g co : controller
- nest g s : service
- nest g res : All

# **Controller**

## **1. Controller 데코레이터**

- @Req() & @Res() & @Next()
- @Session() : req.session
- @Param(key?) & @Body(key?) & @Query(key?)
- @Headers(name?) & @Ip()
- @HostParam() : req.host

```
@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```

## **2. 동적 라우팅**

```
@Get(':id')
findOne(@Param() params): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}

<!--위와 아래는 같다 -->

@Get(':id')
findOne(@Param('id') id: string): string {
  return `This action returns a #${id} cat`;
}

```

## **3. 도메인 확인**

- 요청 URL을 확인하여 로직을 구성할 수 있다.

```
@Controller({ host: 'admin.example.com' })
export class AdminController {
  @Get()
  index(): string {
    return 'Admin page';
  }

```

## **4. 비동기**

```
@Get()
async findAll(): Promise<any[]> {
  return [];
}
```

## **5. DTO사용 시**

- Nest.js에서는 interface대신 class사용을 권장한다. TS에서 JS변환시 class는 실제 엔티티로 보존되기 때문이다.

```
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}


@Post()
async create(@Body() createCatDto: CreateCatDto) {
  return 'This action adds a new cat';
}
```

# **Service**

## **예시**

```
<!--Service-->
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}

<!--Controller-->
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}

```

# **미들웨어**

- 미들웨어 예시

```
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('Request...');
    next();
  }
}

```

- 미들웨어 적용

```
import { Module, NestModule, RequestMethod, MiddlewareConsumer } from '@nestjs/common';
import { LoggerMiddleware } from './common/middleware/logger.middleware';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      <!--미들웨어 적용 제외-->
       .exclude(
    { path: 'cats', method: RequestMethod.GET },
    { path: 'cats', method: RequestMethod.POST },
    'cats/(.*)',
    )
     <!--미들웨어 적용-->
      .forRoutes({ path: 'cats', method: RequestMethod.GET });
      .forRoutes(CatsController);
  }
}
```

- 글로벌 적용

```
<!-- main.ts -->
const app = await NestFactory.create(AppModule);
app.use(logger);
await app.listen(3000);
```
