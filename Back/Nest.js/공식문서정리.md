# **CLI**

- nest g mo : module
- nest g co : controller
- nest g s : service
- nest g res : All

# **Controller**

## **1. Controller 데코레이터**

- @Req() & @Res() & @Next()
- @Session() : req.session
- @Param(key?) & @Body(key?) & @Query(key?)
- @Headers(name?) & @Ip()
- @HostParam() : req.host

```
@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```

## **2. 동적 라우팅**

```
@Get(':id')
findOne(@Param() params): string {
  console.log(params.id);
  return `This action returns a #${params.id} cat`;
}

<!--위와 아래는 같다 -->

@Get(':id')
findOne(@Param('id') id: string): string {
  return `This action returns a #${id} cat`;
}

```

## **3. 도메인 확인**

- 요청 URL을 확인하여 로직을 구성할 수 있다.

```
@Controller({ host: 'admin.example.com' })
export class AdminController {
  @Get()
  index(): string {
    return 'Admin page';
  }

```

## **4. 비동기**

```
@Get()
async findAll(): Promise<any[]> {
  return [];
}
```

## **5. DTO사용 시**

- Nest.js에서는 interface대신 class사용을 권장한다. TS에서 JS변환시 class는 실제 엔티티로 보존되기 때문이다.

```
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}


@Post()
async create(@Body() createCatDto: CreateCatDto) {
  return 'This action adds a new cat';
}
```

# **Service**

## **예시**

```
<!--Service-->
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}

<!--Controller-->
@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}

```
