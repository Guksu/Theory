# **1일차**

- 자료구조는 메모리를 효율적으로 사용하여 빠르고 안정적으로 데이터를 처리하는것이 궁극적인 목표다.
- 알고리즘은 특정 문제를 효율적이고 빠르게 해결하는것이 궁극적인 목표로 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것

- O(n)예제

```
for( let i=0; i<n; i++){

}
```

- O(logN) 예제

```
for (let i=0; i<n; i*2){

}
```

- O(n LogN) 예제

```
for( let i=0; i<n; i++){
    for (let z=0; z<n; z*2){

    }
}
```

- O(n^2)예제

```
for( let i=0; i<n; i++){
    for (let z=0; z<n; z++){

    }
}
```

- 두 변수 바꾸기 간단하게 구현(구조 분해 할당)

```
let a = 5, b = 10;
[a, b] = [b, a];
console.log(a, b); // 10 5
```

- 루프를 함수형 프로그래밍 방식으로 구현

```
let sum = 0;
for (let i = 5; i < 10; i += 1) {
    sum += i;
}

---------->

const sum = Array
    .from(new Array(5), (_, k) => k + 5)
    .reduce((acc, cur) => acc + cur, 0);
```

- !! 연산자를 이용하여 0, null, 빈 문자열, undefined, NaN을 false로 그 외에는 true로 변경할 수 있다.

```
console.log(!!null)  //false
```

- 배열의 중간에 요소를 추가 및 제거하는것은 O(n) 즉 선형시간이 걸린다.

```
arr.splice(3,0,"추가요소")  //추가
arr.splice(3,1)  //제거
```

- 배열 함수들

```
const arr = [1,2,3,4,5]
const arr2 = [10,9,8,7]

arr.reverse   // [5,4,3,2,1]  --> 배열을 영구적으로 변환시킨다.

arr.concat(arr2)  // [1,2,3,4,5,10,9,8,7]

```

- 연결리스트는 일반 배열과 다르게 탐색에 O(n) , 추가 및 제거에 O(1) 이 소요된다.

- 배열은 메모리에 순차적으로 저장되지만 연결리스트는 각각 따로 저장된다.

- Singly Linked List(단일연결리스트)는 Head(첫요소)에서 Tail(마지막요소)까지 단방향으로 이어진다.

- Dobuly Linked List(이중연결리스트)는 양방향으로 이어지며 한 노드에 이전 및 다음 Pointer가 존재한다.

- Circular Linked List Tail이 Head로 연결된다.

- 힙은 이진트리 형태를 가지며 요소가 삽입, 삭제될 때 바로 정렬되는 특징이 있다. 또한, 우선순위가 높은것이 먼저 나간다.
- 힙에는 루트가 가장 큰 값인 최대힙과 루트가 가장 낮은 최소힙이 있다.
- 요소 추가 시 부모요소와 우선순위를 비교하여 진행된다. 따라서 최대시간복잡도는 logN이다.(완전 이진트리 높이는 logN이다.)
- 요소 제거 시 루트를 제거 후 가장 마지막 정점이 루트가된다. 이후 자식과 우선순위를 비교한다. 따라서 최대시간복잡도는 logN이다.
