## **1장**

- creat-react-app을 통해 babel과 webpack을 자동으로 설치해준다.
- bable을 최산JS코드를 이전버전으로 변환해 주는 컴파일러이다.
- webpack은 JS로 만든 프로그램을 배포하기 좋은 형태로 묶어주는 툴이다. 웹팩을 실행하면 하나의 JS파일이 만들어지고 필요에 따라 여러파일을 생성할 수 있다.
- react는 파일명을 .env.development / .env.test / .env.productio으로 설정하여 각각 개발 / 테스트 / 배포용 환경변수를 설정할 수 있다.

## **2장**

# **var의 문제점**

1. 함수스코프

- 스코프란 변수가 사용될 수 있는 영역을 뜻한다. var는 함수스코프를 가지고 있기 떄문에 프로그램 가장 바깥에서 선언하면 전역 변수가된다. 또한 함수안에서 키워드를 사용하지 않고 변수를 선언하면 이는 전역변수가 되는 특징이 있다.

2. 호이스팅

- var로 정의된 함수는 그 변수가 속한 스코프의 최상단으로 끌어올려진다.

3. 재정의 가능

# **const/let의 특징**

1. 블록스코프

2. 호이스팅시 undefined가 아닌 에러가 발생

```
const foo = 1;
{
    console.log(foo) //에러발생
    const foo = 2;
}
```

- 위의 경우 호이스팅이 발생하지 않으면 1이 출력되지만 호이스팅 때문에 에러가 발생한다.

# **화살표함수**

- 화살표함수에선 this와 argument가 바인딩되지않는다. 따라서 argument가 필요한 경우 다음과 같이 사용한다

```
const foo = (...rest) => console.log(rest)
foo(1,2) // [1,2]
```

## **3장**

- 리액트는 UI데이터를 관리하는 방법을 제공하며 UI데이터는 컴포넌트 내부에서 관리되는 상탯값(state)과 부모 컴포넌트에서 내려 주는 속성값(props)으로 구성된다.
- UI데이터가 변경되면 리액트가 render함수를 이용하여 화면을 자동으로 갱신해준다.
- 리엑트의 setState는 비동기적으로 처리된다. 따라서 다음의 코드에서 state는 2가된다.

```
const [count,setCount] = useState(0)
onClick =()=>{
    setCount(count+1);
    setCount(count+1);
}
```

- 위의 코드의 결과값을 3으로 만들고 싶은 경우엔 다음과 같이 코딩한다.

```
const [count,setCount] = useState(0)
onClick =()=>{
    setCount(prev=>prev+1);
    setCount(prev=>prev+1);
}
```

- componentDidMount 는 render 메서드의 첫 번째 반환값이 실제 돔에 반영된 직후 호출된다.
